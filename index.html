<!DOCTYPE html>
<html lang="si">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subtitle Timing Synchronizer with Smart Matching</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/727/727245.png">
    <!-- ‚úÖ Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CLJE123NKC"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-CLJE123NKC');
    </script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 10px; }
        .container { max-width: 900px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); padding: 20px; }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: clamp(20px, 5vw, 32px); }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: clamp(12px, 3vw, 16px); padding: 0 10px; }
        .upload-section { display: grid; grid-template-columns: 1fr; gap: 15px; margin-bottom: 20px; }
        @media (min-width: 640px) { .container { padding: 40px; } .upload-section { grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; } }
        .upload-box { border: 3px dashed #667eea; border-radius: 15px; padding: 20px; text-align: center; transition: all 0.3s; cursor: pointer; }
        .upload-box:hover { border-color: #764ba2; background: #f8f9ff; }
        .upload-box.uploaded { border-color: #10b981; background: #f0fdf4; }
        .upload-box h3 { color: #333; margin-bottom: 10px; font-size: clamp(16px, 4vw, 20px); }
        .upload-box p { color: #666; font-size: clamp(12px, 3vw, 14px); margin-bottom: 15px; }
        .btn { padding: 10px 20px; border: none; border-radius: 10px; font-size: clamp(14px, 3vw, 16px); font-weight: bold; cursor: pointer; transition: all 0.3s; }
        @media (min-width: 640px) { .btn { padding: 12px 30px; } }
        .btn-upload { background: #667eea; color: white; }
        .btn-upload:hover { background: #5568d3; }
        .btn-sync { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-size: clamp(14px, 4vw, 18px); padding: 12px 25px; width: 100%; }
        @media (min-width: 640px) { .btn-sync { padding: 15px 40px; width: auto; } }
        .btn-sync:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .btn-sync:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-download { background: #10b981; color: white; font-size: clamp(14px, 4vw, 18px); padding: 12px 25px; width: 100%; }
        @media (min-width: 640px) { .btn-download { padding: 15px 40px; width: auto; } }
        .btn-download:hover { background: #059669; }
        .button-group { display: flex; flex-direction: column; gap: 10px; justify-content: center; margin-bottom: 20px; }
        @media (min-width: 640px) { .button-group { flex-direction: row; gap: 15px; } }
        .status { background: #eff6ff; border: 2px solid #3b82f6; border-radius: 10px; padding: 12px; text-align: center; margin-bottom: 15px; font-weight: bold; color: #1e40af; font-size: clamp(12px, 3vw, 16px); }
        .status.success { background: #f0fdf4; border-color: #10b981; color: #065f46; }
        .status.error { background: #fef2f2; border-color: #ef4444; color: #991b1b; }
        .status.warning { background: #fffbeb; border-color: #f59e0b; color: #92400e; }
        .preview { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 10px; padding: 15px; margin-bottom: 15px; display: none; }
        .preview h3 { color: #333; margin-bottom: 10px; font-size: clamp(16px, 4vw, 20px); }
        .preview pre { background: white; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb; max-height: 250px; overflow-y: auto; font-size: clamp(10px, 2.5vw, 12px); white-space: pre-wrap; word-break: break-word; }
        .instructions { background: #fef3c7; border: 2px solid #fbbf24; border-radius: 10px; padding: 15px; }
        .instructions h4 { color: #92400e; margin-bottom: 10px; font-size: clamp(14px, 3.5vw, 18px); }
        .instructions ol { color: #78350f; padding-left: 20px; font-size: clamp(12px, 3vw, 14px); }
        .instructions li { margin-bottom: 5px; }
        .instructions p { font-size: clamp(11px, 2.5vw, 13px); }
        input[type="file"] { display: none; }
        .icon { font-size: clamp(32px, 8vw, 48px); margin-bottom: 10px; }
        .checkmark { color: #10b981; font-size: clamp(16px, 4vw, 20px); margin-top: 10px; display: none; }
        .notice {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffeeba;
            border-radius: 10px;
            padding: 10px 15px;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
            font-size: clamp(12px, 3vw, 16px);
        }
        #downloadBtn { display: none; }
        .optional-badge { display: inline-block; background: #fbbf24; color: white; padding: 3px 8px; border-radius: 12px; font-size: clamp(9px, 2vw, 11px); font-weight: bold; margin-left: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="notice">
            üß† Smart Matching ‡∂ë‡∂ö‡∂ß ‡∂∂‡∑ú‡∑Ñ‡∑ù ‡∑Ä‡∑ö‡∂Ω‡∑è‡∑Ä‡∂ö‡∑ä ‡∂ú‡∂≠ ‡∑Ä‡∂±‡∑î ‡∂á‡∂≠. ‡∂ö‡∂ª‡∑î‡∂´‡∑è‡∂ö‡∂ª ‡∂∂‡∂Ω‡∑è ‡∑É‡∑í‡∂ß‡∑í‡∂±‡∑ä‡∂±...
        </div>

        <h1>üé¨ Subtitle Smart Synchronizer</h1>
        <p class="subtitle">Original timing + Sinhala translation smart matching</p>

        <div class="upload-section">
            <div class="upload-box" id="originalBox" onclick="document.getElementById('originalFile').click()">
                <div class="icon">‚è±Ô∏è</div>
                <h3>Original Subtitle</h3>
                <p>(‡∂ï‡∂±‡∑ë‡∂∏ ‡∂∑‡∑è‡∑Ç‡∑è‡∑Ä‡∂ö - timing ‡∑É‡∂≥‡∑Ñ‡∑è)</p>
                <button class="btn btn-upload">üìÅ Upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
                <div class="checkmark" id="originalCheck">‚úì Uploaded</div>
                <input type="file" id="originalFile" accept=".srt">
            </div>

            <div class="upload-box" id="translatedBox" onclick="document.getElementById('translatedFile').click()">
                <div class="icon">üìù</div>
                <h3>Sinhala Subtitle <span class="optional-badge">‡∑Ä‡∑í‡∂ö‡∂Ω‡∑ä‡∂¥</span></h3>
                <p>(‡∂¥‡∂ª‡∑í‡∑Ä‡∂ª‡∑ä‡∂≠‡∂±‡∂∫ ‡∂ö‡∑Ö - ‡∑Ä‡∂†‡∂± ‡∑É‡∂≥‡∑Ñ‡∑è)</p>
                <button class="btn btn-upload">üìÅ Upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
                <div class="checkmark" id="translatedCheck">‚úì Uploaded</div>
                <input type="file" id="translatedFile" accept=".srt">
            </div>
        </div>

        <div id="statusBox" class="status" style="display:none;"></div>

        <div class="button-group">
            <button class="btn btn-sync" id="syncBtn" onclick="syncSubtitles()">üîÑ Smart Sync ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
            <button class="btn btn-download" id="downloadBtn" onclick="downloadOutput()">‚¨áÔ∏è Download ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
        </div>

        <!-- üÜï Real-time Log Box -->
        <div class="preview" id="logBox" style="display:none; background:#000; color:#0f0; max-height:200px; overflow-y:auto;">
            <h3 style="color:white;">Live Log:</h3>
            <pre id="logText" style="background:#000; color:#0f0; border:none; padding:5px; margin:0; white-space:pre-wrap;"></pre>
        </div>

        <div class="preview" id="previewBox">
            <h3>Preview:</h3>
            <pre id="previewText"></pre>
        </div>

        <div class="instructions">
            <h4>üìå ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂± ‡∂Ü‡∂ö‡∑è‡∂ª‡∂∫:</h4>
            <ol>
                <li>‡∂î‡∂∫‡∑è‡∂ß English sub ‡∂ë‡∂ö‡∂ö‡∑ä sinhalata ‡∑Ñ‡∂ª‡∑Ä‡∂±‡∑ä‡∂± ‡∂ï‡∂±‡∑ä‡∂±‡∂∏‡∑ä original subtitle ‡∂≠‡∑ê‡∂±‡∂ß sub ‡∂ë‡∂ö ‡∂Ø‡∑ì‡∂Ω sync button ‡∂ë‡∂ö ‡∂î‡∂∂‡∂±‡∑ä‡∂± </li>
                <li>Original subtitle file ‡∂ë‡∂ö upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂± (timing ‡∑Ä‡∂Ω‡∂ß)</li>
                <li><strong>‡∑Ä‡∑í‡∂ö‡∂Ω‡∑ä‡∂¥:</strong> Sinhala translated subtitle file ‡∂ë‡∂ö upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</li>
                <li>"Smart Sync" button ‡∂ë‡∂ö click ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</li>
                <li>System ‡∂ë‡∂ö Original ‡∂ë‡∂ö‡∑ö English ‡∑É‡∑Ñ Translated ‡∂ë‡∂ö‡∑ö Sinhala compare ‡∂ö‡∂ª‡∂Ω‡∑è best match ‡∑Ñ‡∑ú‡∂∫‡∑è‡∂ú‡∑ô‡∂± sync ‡∂ö‡∂ª‡∂∫‡∑í</li>
                <li>Output file ‡∂ë‡∂ö download ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</li>
            </ol>
            <p style="margin-top:10px;"><strong>üß† Smart Matching Logic:</strong></p>
            <ul style="padding-left: 20px; margin-top: 5px;">
                <li>‡∂¥‡∑Ö‡∂∏‡∑î‡∑Ä Translated file ‡∂ë‡∂ö‡∑ö ‡∑Ñ‡∑ú‡∂≥‡∂∏ match ‡∂ë‡∂ö ‡∑Ñ‡∑ú‡∂∫‡∂±‡∑Ä‡∑è (85%+ accuracy)</li>
                <li>Match ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ñ‡∑ú‡∂∫‡∑è‡∂ú‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∂±‡∂∏‡∑ä, Google Translate use ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è</li>
                <li>Original ‡∂ë‡∂ö‡∑ö "Stop it, Robert!" ‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä, Translated ‡∂ë‡∂ö‡∑ö "‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂±‡∑ä‡∂± ‡∂ª‡∑ú‡∂∂‡∂ß‡∑ä!" ‡∑Ñ‡∑ú‡∂∫‡∑è‡∂ú‡∑ô‡∂± ‡∂í‡∂ö ‡∂Ø‡∑ô‡∂±‡∑Ä‡∑è</li>
                <li>Dataset ‡∂ë‡∂ö use ‡∂ö‡∂ª‡∂Ω‡∑è Sinhala words intelligently match ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è</li>
            </ul>
        </div>
    </div>

    <script>
        let originalContent = null;
        let translatedContent = null;
        let outputContent = null;

        // üá±üá∞ Sinhala Language Dataset for Smart Matching
        const sinhalaDataset = {
            // Common conversational words and their variations
            commonWords: {
                '‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂±‡∑ä‡∂±': ['‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂±‡∑ä‡∂±', '‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂Ω‡∑è', '‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂¥‡∂±‡∑ä', '‡∂±‡∂≠‡∂ª', '‡∂±‡∂≠‡∂ª‡∂ö‡∂ª‡∂±‡∑ä‡∂±', '‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∑è', 'stop', '‡∂±‡∑Ä‡∂≠‡∑ä‡∑Ä‡∂¥‡∂Ω‡∑ä‡∂Ω‡∑è'],
                '‡∑Ñ‡∑ú‡∂≥': ['‡∑Ñ‡∑ú‡∂≥', '‡∑Ñ‡∑ú‡∂≥‡∂∫‡∑í', '‡∑Ñ‡∑ú‡∂≥‡∂ß', '‡∑Ñ‡∑ú‡∂Ø‡∂∫‡∑í', '‡∑Ñ‡∑ú‡∂Ø', '‡∑Ñ‡∑ú‡∂Ø‡∂ß', 'well', 'good', 'fine'],
                '‡∂±‡∑ë': ['‡∂±‡∑ë', '‡∂±‡∑ê‡∑Ñ‡∑ê', '‡∂±‡∑ê‡∂≠', '‡∂±‡∑ê‡∂≠‡∑í', '‡∂±‡∑ë‡∂±‡∑ö', 'no', 'not'],
                '‡∂î‡∑Ä‡∑ä': ['‡∂î‡∑Ä‡∑ä', '‡∂î‡∑Ä', '‡∂ï‡∑Ä‡∑ä', '‡∂ï', '‡∑Ñ‡∂ª‡∑í', '‡∑Ñ‡∂ª‡∑í‡∂Ø', 'yes', 'ok', 'okay'],
                '‡∂ö‡∂ª‡∂±‡∑ä‡∂±': ['‡∂ö‡∂ª‡∂±‡∑ä‡∂±', '‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∂ö‡∑ù', '‡∂ö‡∂ª‡∂¥‡∂±‡∑ä', '‡∂ö‡∂ª‡∂Ω‡∑è', '‡∂ö‡∑Ö‡∑è', '‡∂ö‡∂ª‡∂±‡∑Ä‡∑è', '‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö'],
                '‡∂ë‡∂±‡∑ä‡∂±': ['‡∂ë‡∂±‡∑ä‡∂±', '‡∂ë‡∂±‡∑ä‡∂±‡∂ö‡∑ù', '‡∂ë‡∂±‡∑Ä‡∑è', '‡∂Ü‡∑Ä‡∑è', '‡∂ë‡∂±‡∑ä‡∂±‡∑ö', 'come'],
                '‡∂∫‡∂±‡∑ä‡∂±': ['‡∂∫‡∂±‡∑ä‡∂±', '‡∂∫‡∂±‡∑ä‡∂±‡∂ö‡∑ù', '‡∂∫‡∂±‡∑Ä‡∑è', '‡∂ú‡∑í‡∂∫‡∑è', '‡∂∫‡∂±‡∑ä‡∂±‡∑ö', 'go'],
                '‡∂∂‡∂Ω‡∂±‡∑ä‡∂±': ['‡∂∂‡∂Ω‡∂±‡∑ä‡∂±', '‡∂∂‡∂Ω‡∂±‡∑ä‡∂±‡∂ö‡∑ù', '‡∂∂‡∂Ω‡∂±‡∑Ä‡∑è', '‡∂∂‡∑ê‡∂Ω‡∑î‡∑Ä‡∑è', '‡∂∂‡∂Ω‡∂±‡∑ä‡∂±‡∑ö', 'look', 'see'],
                '‡∂ö‡∂≠‡∑è': ['‡∂ö‡∂≠‡∑è', '‡∂ö‡∂≠‡∑è‡∑Ä', '‡∂ö‡∂≠‡∑è‡∂ö‡∂ª‡∂±‡∑ä‡∂±', '‡∂ö‡∂≠‡∑è‡∂ö‡∂ª‡∂±‡∑Ä‡∑è', 'talk', 'speak'],
                '‡∂∏‡∂∏': ['‡∂∏‡∂∏', '‡∂∏‡∂Ç', '‡∂∏‡∂∏‡∂≠‡∑ä', '‡∂∏‡∂ú‡∑ö', '‡∂∏‡∂ß', '‡∂∏‡∑è', 'i', 'me', 'my'],
                '‡∂î‡∂∫‡∑è': ['‡∂î‡∂∫‡∑è', '‡∂î‡∂∂', '‡∂î‡∂∫‡∑è‡∂ú‡∑ö', '‡∂î‡∂∫‡∑è‡∂ß', '‡∂î‡∂∫‡∑è‡∂≠‡∑ä', 'you', 'your'],
                '‡∂ë‡∂∫‡∑è': ['‡∂ë‡∂∫‡∑è', '‡∂î‡∑Ñ‡∑î', '‡∂á‡∂∫', '‡∂ë‡∂∫‡∑è‡∂ú‡∑ö', '‡∂ë‡∂∫‡∑è‡∂ß', 'he', 'she', 'him', 'her'],
                '‡∂Ö‡∂¥‡∑í': ['‡∂Ö‡∂¥‡∑í', '‡∂Ö‡∂¥‡∑í‡∂≠‡∑ä', '‡∂Ö‡∂¥‡∑ö', '‡∂Ö‡∂¥‡∂ß', 'we', 'us', 'our'],
                '‡∂í‡∂ö': ['‡∂í‡∂ö', '‡∂ë‡∂∫', '‡∂í‡∂ö‡∑ö', '‡∂í‡∂ö‡∂ß', 'that', 'it'],
                '‡∂∏‡∑ö‡∂ö': ['‡∂∏‡∑ö‡∂ö', '‡∂∏‡∑ô‡∂∫', '‡∂∏‡∑ö‡∂ö‡∑ö', '‡∂∏‡∑ö‡∂ö‡∂ß', 'this'],
                '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è': ['‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è', '‡∂≠‡∑í‡∂∂‡∑ô‡∂±‡∑Ä‡∑è', '‡∂á‡∂≠', '‡∂≠‡∑í‡∂∂‡∑î‡∂´‡∑è', '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑ä‡∂±‡∑ö', 'have', 'has'],
                '‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è': ['‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è', '‡∑Ä‡∑ö', '‡∑Ä‡∑î‡∂´‡∑è', '‡∑Ä‡∑í‡∂∫', '‡∑Ä‡∑ô‡∂±‡∑ä‡∂±‡∑ö', '‡∑Ä‡∑ô‡∂±', 'happen', 'become'],
                '‡∂Ø‡∂±‡∑ä‡∂±‡∑Ä‡∑è': ['‡∂Ø‡∂±‡∑ä‡∂±‡∑Ä‡∑è', '‡∂Ø‡∑ê‡∂±‡∂ú‡∑ô‡∂±', '‡∂Ø‡∑ê‡∂±', '‡∂Ø‡∂±‡∑ä‡∂±‡∑ö', 'know'],
                '‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±': ['‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±', '‡∂ö‡∑í‡∂∫‡∂±‡∑Ä‡∑è', '‡∂ö‡∑í‡∑Ä‡∑ä‡∑Ä‡∑è', '‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö', 'tell', 'say'],
                '‡∂Ü‡∂Ø‡∂ª‡∑ô‡∂∫‡∑í': ['‡∂Ü‡∂Ø‡∂ª‡∑ô‡∂∫‡∑í', '‡∂Ü‡∂Ø‡∂ª‡∂∫', '‡∂Ü‡∂Ø‡∂ª‡∑ö', 'love'],
                '‡∑É‡∂∏‡∑è‡∑Ä‡∑ô‡∂±‡∑ä‡∂±': ['‡∑É‡∂∏‡∑è‡∑Ä‡∑ô‡∂±‡∑ä‡∂±', '‡∑É‡∂∏‡∑è‡∑Ä‡∂±‡∑ä‡∂±', '‡∑É‡∂∏‡∑è‡∑Ä', 'sorry', 'excuse'],
                '‡∑É‡∑ä‡∂≠‡∑ñ‡∂≠‡∑í‡∂∫‡∑í': ['‡∑É‡∑ä‡∂≠‡∑ñ‡∂≠‡∑í‡∂∫‡∑í', '‡∑É‡∑ä‡∂≠‡∑î‡∂≠‡∑í', '‡∑É‡∑ä‡∂≠‡∑ñ‡∂≠‡∑í', 'thanks', 'thank'],
            },
            
            // Common name transliterations
            names: {
                'robert': ['‡∂ª‡∑ú‡∂∂‡∂ß‡∑ä', '‡∂ª‡∑ú‡∂∂‡∂ª‡∑ä‡∂ß‡∑ä', '‡∂ª‡∑ú‡∂∂‡∂ª‡∑ä‡∂ß', 'robert'],
                'sara': ['‡∑É‡∑è‡∂ª‡∑è', '‡∑É‡∂ª‡∑è', 'sara', 'sarah'],
                'john': ['‡∂¢‡∑ù‡∂±‡∑ä', '‡∂¢‡∑ú‡∂±‡∑ä', 'john'],
                'david': ['‡∂©‡∑ö‡∑Ä‡∑í‡∂©‡∑ä', '‡∂©‡∑ö‡∑Ä‡∑í‡∂©', 'david'],
                'mary': ['‡∂∏‡∑ö‡∂ª‡∑í', '‡∂∏‡∂ª‡∑í', 'mary'],
                'james': ['‡∂¢‡∑ö‡∂∏‡∑ä‡∑É‡∑ä', '‡∂¢‡∑ö‡∂∏‡∑ä‡∑É', 'james'],
                'michael': ['‡∂∏‡∂∫‡∑í‡∂ö‡∂Ω‡∑ä', '‡∂∏‡∂∫‡∑í‡∂ö‡∂Ω', 'michael'],
                'anna': ['‡∂á‡∂±‡∑è', '‡∂á‡∂±‡∑ä‡∂±‡∑è', 'anna'],
            },
            
            // Common phrases
            phrases: {
                'how are you': ['‡∂ö‡∑ú‡∑Ñ‡∑ú‡∂∏‡∂Ø', '‡∂ö‡∑ú‡∑Ñ‡∑ú‡∂∏‡∂Ø ‡∂î‡∂∫‡∑è', '‡∂î‡∂∫‡∑è ‡∂ö‡∑ú‡∑Ñ‡∑ú‡∂∏‡∂Ø', '‡∑Ñ‡∑ú‡∂≥‡∑í‡∂±‡∑ä‡∂Ø'],
                'i love you': ['‡∂∏‡∂∏ ‡∂î‡∂∫‡∑è‡∂ß ‡∂Ü‡∂Ø‡∂ª‡∑ô‡∂∫‡∑í', '‡∂Ü‡∂Ø‡∂ª‡∑ô‡∂∫‡∑í', '‡∂∏‡∂Ç ‡∂Ü‡∂Ø‡∂ª‡∑ô‡∂∫‡∑í ‡∂î‡∂∫‡∑è‡∂ß'],
                'thank you': ['‡∑É‡∑ä‡∂≠‡∑ñ‡∂≠‡∑í‡∂∫‡∑í', '‡∂∂‡∑ú‡∑Ñ‡∑ú‡∂∏ ‡∑É‡∑ä‡∂≠‡∑ñ‡∂≠‡∑í‡∂∫‡∑í', '‡∑É‡∑ä‡∂≠‡∑î‡∂≠‡∑í'],
                'i am sorry': ['‡∂∏‡∂∏ ‡∑É‡∂∏‡∑è‡∑Ä‡∑ô‡∂±‡∑ä‡∂±', '‡∑É‡∂∏‡∑è‡∑Ä‡∑ô‡∂±‡∑ä‡∂±', '‡∂∏‡∂Ç ‡∑É‡∂∏‡∑è‡∑Ä‡∑ô‡∂±‡∑ä‡∂±'],
                'what happened': ['‡∂∏‡∑ú‡∂ö‡∂Ø ‡∑Ä‡∑î‡∂´‡∑ö', '‡∂∏‡∑ú‡∂ö‡∂Ø ‡∂ã‡∂±‡∑ö', '‡∑Ä‡∑î‡∂´‡∑ö ‡∂∏‡∑ú‡∂ö‡∂Ø'],
                'dont worry': ['‡∂ö‡∂ª‡∂Ø‡∂ª ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ë‡∂¥‡∑è', '‡∂ö‡∂´‡∂ú‡∑è‡∂ß‡∑î ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ë‡∂¥‡∑è', '‡∂∂‡∂∫ ‡∑Ä‡∑ô‡∂±‡∑ä‡∂± ‡∂ë‡∂¥‡∑è'],
                'come here': ['‡∂∏‡∑ô‡∑Ñ‡∑ô‡∂ß ‡∂ë‡∂±‡∑ä‡∂±', '‡∂∏‡∑ô‡∂≠‡∂±‡∂ß ‡∂ë‡∂±‡∑ä‡∂±', '‡∂ë‡∂±‡∑ä‡∂± ‡∂∏‡∑ô‡∑Ñ‡∑ô‡∂ß'],
                'lets go': ['‡∂∫‡∂∏‡∑î', '‡∂Ö‡∂¥‡∑í ‡∂∫‡∂∏‡∑î', '‡∂∫‡∂±‡∑ä‡∂± ‡∂∫‡∂∏‡∑î'],
            },
            
            // Emotional words
            emotions: {
                'happy': ['‡∑É‡∂≠‡∑î‡∂ß‡∑î', '‡∑É‡∂≠‡∑î‡∂ß‡∑î‡∂∫‡∑í', '‡∑É‡∂≠‡∑î‡∂ß', '‡∑É‡∂±‡∑ä‡∂≠‡∑ù‡∑Ç', '‡∂¥‡∑ä‚Äç‡∂ª‡∑ì‡∂≠‡∑í‡∂∫‡∑í'],
                'sad': ['‡∂Ø‡∑î‡∂ö', '‡∂Ø‡∑î‡∂ö‡∂∫‡∑í', '‡∂Ø‡∑î‡∂ö‡∑í‡∂±‡∑ä', '‡∂ö‡∂´‡∂ú‡∑è‡∂ß‡∑î'],
                'angry': ['‡∂≠‡∂ª‡∑Ñ', '‡∂≠‡∂ª‡∑Ñ‡∂∫‡∑í', '‡∂≠‡∂ª‡∑Ñ‡∑è', '‡∂ö‡∑ù‡∂¥'],
                'afraid': ['‡∂∂‡∂∫', '‡∂∂‡∂∫‡∂∫‡∑í', '‡∂∂‡∑í‡∂∫‡∑ô‡∂±‡∑ä', '‡∂∂‡∑í‡∂∫'],
                'tired': ['‡∂∏‡∑Ñ‡∂±‡∑ä‡∑É‡∑í‡∂∫‡∑í', '‡∂∏‡∑Ñ‡∂±‡∑ä‡∑É‡∑í', '‡∂∏‡∑Ñ‡∂±‡∑ä‡∑É', '‡∑Ä‡∑ô‡∑Ñ‡∑ô‡∑É‡∂ß'],
                'sick': ['‡∂Ö‡∑É‡∂±‡∑ì‡∂¥', '‡∂Ö‡∑É‡∂±‡∑ì‡∂¥‡∂∫‡∑í', '‡∂ª‡∑ù‡∂ú‡∑ì'],
            }
        };

        // üîç Check if word exists in Sinhala dataset
        function findInDataset(word) {
            word = word.toLowerCase();
            
            // Check all categories
            for (const category of Object.values(sinhalaDataset)) {
                for (const [key, variations] of Object.entries(category)) {
                    if (variations.some(v => v.toLowerCase() === word || 
                                           v.toLowerCase().includes(word) || 
                                           word.includes(v.toLowerCase()))) {
                        return variations;
                    }
                }
            }
            return null;
        }

        // üéØ Enhanced word matching using dataset
        function matchWordsWithDataset(word1, word2) {
            const variations1 = findInDataset(word1);
            const variations2 = findInDataset(word2);
            
            if (variations1 && variations2) {
                // Check if they share the same root word
                const intersection = variations1.filter(v => variations2.includes(v));
                if (intersection.length > 0) {
                    return 1.0; // Perfect match via dataset
                }
            }
            
            // Check if word2 is in word1's variations
            if (variations1 && variations1.some(v => v.toLowerCase() === word2.toLowerCase())) {
                return 0.95;
            }
            
            // Check if word1 is in word2's variations
            if (variations2 && variations2.some(v => v.toLowerCase() === word1.toLowerCase())) {
                return 0.95;
            }
            
            return 0;
        }

        // üÜï Real-time log function
        function log(message) {
            const logBox = document.getElementById("logBox");
            const logText = document.getElementById("logText");
            logBox.style.display = "block";
            logText.textContent += message + "\n";
            logBox.scrollTop = logBox.scrollHeight; // auto scroll
        }

        document.getElementById('originalFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                originalContent = event.target.result;
                document.getElementById('originalBox').classList.add('uploaded');
                document.getElementById('originalCheck').style.display = 'block';
                showStatus('Original subtitle ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä upload ‡∑Ä‡∑î‡∂´‡∑è ‚úì', 'success');
                log("üü¶ Original subtitle loaded");
            };
            reader.readAsText(file);
        });

        document.getElementById('translatedFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                translatedContent = event.target.result;
                document.getElementById('translatedBox').classList.add('uploaded');
                document.getElementById('translatedCheck').style.display = 'block';
                showStatus('Sinhala subtitle ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä upload ‡∑Ä‡∑î‡∂´‡∑è ‚úì', 'success');
                log("üü© Translated subtitle loaded");
            };
            reader.readAsText(file);
        });

        function parseSRT(content) {
            const blocks = content.trim().split(/\n\s*\n/);
            return blocks.map(block => {
                const lines = block.split('\n');
                const index = lines[0];
                const timing = lines[1];
                const text = lines.slice(2).join('\n');
                return { index, timing, text };
            });
        }

        function normalizeText(text) {
            return text.toLowerCase()
                .replace(/[.,!?;:"""''\-‚Äî()[\]{}]/g, '')
                .replace(/\s+/g, ' ')
                .replace(/\d+/g, '')  // Remove numbers
                .trim();
        }

        // üß† Advanced Levenshtein Distance with optimizations
        function levenshteinDistance(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            if (len1 === 0) return len2;
            if (len2 === 0) return len1;
            
            const matrix = Array(len2 + 1).fill(null).map(() => Array(len1 + 1).fill(0));
            
            for (let i = 0; i <= len1; i++) matrix[0][i] = i;
            for (let j = 0; j <= len2; j++) matrix[j][0] = j;
            
            for (let j = 1; j <= len2; j++) {
                for (let i = 1; i <= len1; i++) {
                    const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
                    matrix[j][i] = Math.min(
                        matrix[j][i - 1] + 1,
                        matrix[j - 1][i] + 1,
                        matrix[j - 1][i - 1] + cost
                    );
                }
            }
            return matrix[len2][len1];
        }

        // üéØ Ultra-enhanced similarity with Sinhala dataset integration
        function calculateSimilarity(str1, str2) {
            if (!str1 || !str2) return 0;
            
            // If strings are very similar in length, they're more likely to match
            const lengthRatio = Math.min(str1.length, str2.length) / Math.max(str1.length, str2.length);
            if (lengthRatio < 0.25) return 0; // Too different in length
            
            // Levenshtein-based similarity
            const dist = levenshteinDistance(str1, str2);
            const maxLen = Math.max(str1.length, str2.length);
            const baseSimilarity = 1 - (dist / maxLen);
            
            // Word-level matching with Sinhala dataset enhancement
            const words1 = str1.split(/\s+/).filter(w => w.length > 1);
            const words2 = str2.split(/\s+/).filter(w => w.length > 1);
            
            let commonWords = 0;
            let datasetMatches = 0;
            
            for (const word1 of words1) {
                let bestWordMatch = 0;
                for (const word2 of words2) {
                    // First try dataset matching
                    const datasetScore = matchWordsWithDataset(word1, word2);
                    if (datasetScore > 0) {
                        bestWordMatch = Math.max(bestWordMatch, datasetScore);
                        if (datasetScore >= 0.95) datasetMatches++;
                        continue;
                    }
                    
                    // Then try regular matching
                    if (word1 === word2) {
                        bestWordMatch = 1;
                        break;
                    } else if (word1.length > 3 && word2.length > 3) {
                        // Check if one word contains the other
                        if (word1.includes(word2) || word2.includes(word1)) {
                            bestWordMatch = Math.max(bestWordMatch, 0.7);
                        } else {
                            // Check character similarity for transliteration
                            const wordSim = 1 - (levenshteinDistance(word1, word2) / Math.max(word1.length, word2.length));
                            if (wordSim > 0.6) {
                                bestWordMatch = Math.max(bestWordMatch, wordSim * 0.8);
                            }
                        }
                    }
                }
                commonWords += bestWordMatch;
            }
            
            // Extra bonus for dataset matches
            const datasetBonus = datasetMatches > 0 ? (datasetMatches / words1.length) * 0.15 : 0;
            
            const wordMatchRatio = words1.length > 0 ? commonWords / words1.length : 0;
            const wordBonus = wordMatchRatio * 0.40;
            
            // Length similarity with more tolerance
            const lengthDiff = Math.abs(str1.length - str2.length);
            const lengthSimilarity = 1 - (lengthDiff / maxLen);
            const lengthBonus = Math.pow(lengthSimilarity, 1.5) * 0.12;
            
            // Character n-gram matching for better fuzzy matching
            const ngramSimilarity = calculateNgramSimilarity(str1, str2, 3);
            const ngramBonus = ngramSimilarity * 0.18;
            
            const finalScore = Math.min(1, baseSimilarity * 0.40 + wordBonus + lengthBonus + ngramBonus + datasetBonus);
            return finalScore;
        }
        
        // N-gram similarity for fuzzy matching
        function calculateNgramSimilarity(str1, str2, n = 3) {
            if (str1.length < n || str2.length < n) return 0;
            
            const ngrams1 = new Set();
            const ngrams2 = new Set();
            
            for (let i = 0; i <= str1.length - n; i++) {
                ngrams1.add(str1.substr(i, n));
            }
            
            for (let i = 0; i <= str2.length - n; i++) {
                ngrams2.add(str2.substr(i, n));
            }
            
            let intersection = 0;
            for (const ngram of ngrams1) {
                if (ngrams2.has(ngram)) intersection++;
            }
            
            const union = ngrams1.size + ngrams2.size - intersection;
            return union > 0 ? intersection / union : 0;
        }

        async function translateText(text) {
            try {
                const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=si&dt=t&q=${encodeURIComponent(text)}`);
                const data = await response.json();
                if (data && data[0] && data[0][0] && data[0][0][0]) {
                    let translatedText = '';
                    // Combine all translation segments
                    for (let i = 0; i < data[0].length; i++) {
                        if (data[0][i][0]) {
                            translatedText += data[0][i][0];
                        }
                    }
                    translatedText = makeSinhalaConversational(translatedText);
                    return translatedText;
                }
                return text;
            } catch (error) {
                console.error('Translation error:', error);
                return text;
            }
        }

        function makeSinhalaConversational(text) {
            let result = text;
            
            // Apply dataset-based conversions first
            const conversions = {
                '‡∂á‡∂≠': '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è','‡∂±‡∑ê‡∂≠': '‡∂±‡∑ë','‡∂î‡∂∂': '‡∂î‡∂∫‡∑è','‡∂î‡∑Ñ‡∑î': '‡∂ë‡∂∫‡∑è','‡∂á‡∂∫': '‡∂ë‡∂∫‡∑è','‡∂ë‡∂∫': '‡∂í‡∂ö','‡∂∏‡∑ô‡∂∫': '‡∂∏‡∑ö‡∂ö',
                '‡∂ö‡∂ª‡∂±‡∑î ‡∂Ω‡∑ê‡∂∂‡∑ö': '‡∂ö‡∂ª‡∂±‡∑Ä‡∑è','‡∂Ω‡∑ê‡∂∂‡∑ö': '‡∂Ω‡∑ê‡∂∂‡∑ô‡∂±‡∑Ä‡∑è','‡∑Ä‡∑ö': '‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è','‡∑Ä‡∑í‡∂∫': '‡∂ã‡∂±‡∑è','‡∂ö‡∑Ö': '‡∂ö‡∑Ö‡∑è','‡∂∫‡∂±‡∑Ä‡∑è': '‡∂∫‡∂±‡∑Ä‡∑è',
                '‡∂ë‡∂±‡∑Ä‡∑è': '‡∂ë‡∂±‡∑Ä‡∑è','‡∂á‡∂≠‡∑ä‡∂≠‡∑ö': '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑ä‡∂±‡∑ö','‡∂ö‡∂ª‡∂∏‡∑í': '‡∂ö‡∂ª‡∂±‡∑Ä‡∑è','‡∂∫‡∂∏‡∑í': '‡∂∫‡∂±‡∑Ä‡∑è','‡∂ë‡∂∏‡∑í': '‡∂ë‡∂±‡∑Ä‡∑è','‡∂ö‡∑Ö‡∑ô‡∂∏‡∑í': '‡∂ö‡∑Ö‡∑è',
                '‡∂ú‡∑í‡∂∫‡∑ô‡∂∏‡∑í': '‡∂ú‡∑í‡∂∫‡∑è','‡∂Ü‡∑Ä‡∑ô‡∂∏‡∑í': '‡∂Ü‡∑Ä‡∑è','‡∂î‡∂∂‡∂ß': '‡∂î‡∂∫‡∑è‡∂ß','‡∂î‡∂∂‡∑ö': '‡∂î‡∂∫‡∑è‡∂ú‡∑ö','‡∂î‡∂∂': '‡∂î‡∂∫‡∑è',
                '‡∂±‡∑ú‡∂∏‡∑ê‡∂≠': '‡∂±‡∑ë','‡∂±‡∑ê‡∂≠‡∑í': '‡∂±‡∑ë','‡∂±‡∑ê‡∑Ñ‡∑ê': '‡∂±‡∑ë',
                '‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö': '‡∂ö‡∂ª‡∂±‡∑ä‡∂±‡∑ö','‡∂∫‡∂±‡∑ä‡∂±‡∑ö': '‡∂∫‡∂±‡∑ä‡∂±‡∑ö','‡∂ë‡∂±‡∑ä‡∂±‡∑ö': '‡∂ë‡∂±‡∑ä‡∂±‡∑ö',
                '‡∑É‡∑í‡∂ß‡∑í‡∂±‡∑Ä‡∑è': '‡∂â‡∂±‡∑ä‡∂±‡∑Ä‡∑è','‡∑É‡∑í‡∂ß‡∑ì': '‡∂â‡∂±‡∑ä‡∂±‡∑Ä‡∑è','‡∑É‡∑í‡∂ß‡∑í‡∂∫‡∑è': '‡∑Ñ‡∑í‡∂ß‡∑í‡∂∫‡∑è',
                '‡∂ö‡∂ª‡∂∫‡∑í': '‡∂ö‡∂ª‡∂±‡∑Ä‡∑è','‡∂∫‡∂∫‡∑í': '‡∂∫‡∂±‡∑Ä‡∑è','‡∂ë‡∂∫‡∑í': '‡∂ë‡∂±‡∑Ä‡∑è',
                '‡∂ö‡∑Ö‡∑ö‡∂∫': '‡∂ö‡∑Ö‡∑è','‡∂ú‡∑í‡∂∫‡∑ö‡∂∫': '‡∂ú‡∑í‡∂∫‡∑è','‡∂Ü‡∑Ä‡∑ö‡∂∫': '‡∂Ü‡∑Ä‡∑è',
                '‡∂≠‡∑í‡∂∂‡∑ö': '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è','‡∂≠‡∑í‡∂∂‡∑î‡∂´‡∑í': '‡∂≠‡∑í‡∂∂‡∑î‡∂´‡∑è','‡∂≠‡∑í‡∂∂‡∑ô‡∂±‡∑Ä‡∑è': '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è',
                '‡∂Ø‡∑ê‡∂±‡∂ú‡∂±‡∑ä‡∂±': '‡∂Ø‡∂±‡∑ä‡∂±','‡∂Ø‡∑ê‡∂±‡∂ú‡∂±‡∑í‡∂∏‡∑í': '‡∂Ø‡∂±‡∑ä‡∂±‡∑Ä‡∑è',
                '‡∂ö‡∑í‡∂∫‡∂±‡∑Ä‡∑è‡∂Ø': '‡∂ö‡∑í‡∂∫‡∂±‡∑Ä‡∂Ø','‡∂ö‡∂ª‡∂±‡∑Ä‡∑è‡∂Ø': '‡∂ö‡∂ª‡∂±‡∑Ä‡∂Ø',
                '‡∂î‡∑Ä‡∑î‡∂±‡∑ä': '‡∂ë‡∂∫‡∑è‡∂Ω‡∑è','‡∂î‡∑Ä‡∑î‡∂±‡∑ä‡∂ú‡∑ö': '‡∂ë‡∂∫‡∑è‡∂Ω‡∂ú‡∑ö','‡∂î‡∑Ä‡∑î‡∂±‡∑ä‡∂ß': '‡∂ë‡∂∫‡∑è‡∂Ω‡∂ß',
                '‡∂á‡∂≠‡∑í': '‡∂á‡∂≠‡∑í','‡∂±‡∑ë': '‡∂±‡∑ë','‡∂±‡∑ê‡∂Ø‡∑ä‡∂Ø': '‡∂±‡∑ê‡∂Ø‡∑ä‡∂Ø',
            };
            
            for (const [formal, informal] of Object.entries(conversions)) {
                const regex = new RegExp('\\b' + formal + '\\b', 'g');
                result = result.replace(regex, informal);
            }
            
            // Remove trailing ‡∂∫ for more conversational feel
            result = result.replace(/‡∂∫$/g, '');
            result = result.replace(/‡∂∫\s/g, ' ');
            
            return result;
        }

        // üîç Ultra-smart matching with multiple strategies
        const translationCache = new Map();
        
        async function getCachedTranslation(text) {
            if (translationCache.has(text)) {
                return translationCache.get(text);
            }
            const translation = await translateText(text);
            translationCache.set(text, translation);
            return translation;
        }

        // Extract key phrases for better matching
        function extractKeyPhrases(text) {
            const normalized = normalizeText(text);
            const words = normalized.split(/\s+/).filter(w => w.length > 2);
            return words;
        }

        async function findBestMatch(originalText, translatedSubs, usedIndices, currentIndex, originalSubs) {
            let bestMatch = null, bestScore = 0, bestIndex = -1;
            
            // Get translation once for this subtitle
            const originalTranslation = await getCachedTranslation(originalText);
            const normalizedTranslation = normalizeText(originalTranslation);
            const translationKeywords = extractKeyPhrases(originalTranslation);
            
            log(`üìù Translated to: ${originalTranslation.slice(0, 60)}...`);
            
            // Pass 1: Sequential matching with wider radius
            const searchRadius = 15;
            const startIdx = Math.max(0, currentIndex - searchRadius);
            const endIdx = Math.min(translatedSubs.length, currentIndex + searchRadius);
            
            for (let i = startIdx; i < endIdx; i++) {
                if (usedIndices.has(i)) continue;
                const translatedText = translatedSubs[i].text;
                const normalizedTranslated = normalizeText(translatedText);
                
                // Calculate base similarity
                let similarity = calculateSimilarity(normalizedTranslation, normalizedTranslated);
                
                // Keyword matching boost
                const translatedKeywords = extractKeyPhrases(translatedText);
                let keywordMatches = 0;
                for (const keyword of translationKeywords) {
                    if (translatedKeywords.some(tk => tk.includes(keyword) || keyword.includes(tk))) {
                        keywordMatches++;
                    }
                }
                const keywordBoost = translationKeywords.length > 0 ? 
                    (keywordMatches / translationKeywords.length) * 0.25 : 0;
                
                similarity += keywordBoost;
                
                // Strong position bonus for sequential matching
                const distance = Math.abs(i - currentIndex);
                const positionBonus = distance === 0 ? 1.20 : 
                    distance <= 2 ? 1.15 :
                    (1 - (distance / searchRadius) * 0.20);
                const finalScore = similarity * positionBonus;
                
                if (finalScore > 0.40) {
                    log(`   [${i}] "${translatedText.slice(0, 40)}..." Score: ${(similarity * 100).toFixed(1)}% ‚Üí Final: ${(finalScore * 100).toFixed(1)}%`);
                }
                
                if (finalScore > bestScore) {
                    bestScore = finalScore;
                    bestMatch = translatedText;
                    bestIndex = i;
                }
                
                // Early exit for excellent matches
                if (similarity > 0.88) {
                    log(`   ‚ö° Excellent match found! Stopping search.`);
                    break;
                }
            }
            
            // Pass 2: Global search with more aggressive matching
            if (bestScore < 0.48) {
                log(`   üîç Expanding search to entire file...`);
                for (let i = 0; i < translatedSubs.length; i++) {
                    if (usedIndices.has(i) || (i >= startIdx && i < endIdx)) continue;
                    
                    const translatedText = translatedSubs[i].text;
                    const normalizedTranslated = normalizeText(translatedText);
                    let similarity = calculateSimilarity(normalizedTranslation, normalizedTranslated);
                    
                    // Keyword boost for global search too
                    const translatedKeywords = extractKeyPhrases(translatedText);
                    let keywordMatches = 0;
                    for (const keyword of translationKeywords) {
                        if (translatedKeywords.some(tk => tk.includes(keyword) || keyword.includes(tk))) {
                            keywordMatches++;
                        }
                    }
                    const keywordBoost = translationKeywords.length > 0 ? 
                        (keywordMatches / translationKeywords.length) * 0.30 : 0;
                    
                    similarity += keywordBoost;
                    
                    if (similarity > bestScore) {
                        bestScore = similarity;
                        bestMatch = translatedText;
                        bestIndex = i;
                        if (similarity > 0.45) {
                            log(`   [${i}] Found better: ${(similarity * 100).toFixed(1)}%`);
                        }
                    }
                    
                    if (similarity > 0.80) break;
                }
            }
            
            // Accept match with lower threshold
            if (bestScore > 0.42 && bestIndex !== -1) {
                usedIndices.add(bestIndex);
                log(`üéØ MATCHED! Score: ${(bestScore * 100).toFixed(1)}% at index ${bestIndex}`);
                log(`   Match: "${bestMatch.slice(0, 60)}..."`);
                return bestMatch;
            }
            
            log(`‚ùå No good match found (best: ${(bestScore * 100).toFixed(1)}%)`);
            return null;
        }

        async function syncSubtitles() {
            if (!originalContent) { showStatus('‚ö†Ô∏è Original subtitle file ‡∂ë‡∂ö upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±!', 'error'); return; }
            const syncBtn = document.getElementById('syncBtn');
            syncBtn.disabled = true;
            syncBtn.textContent = '‚è≥ Processing...';
            document.getElementById("logText").textContent = "";

            try {
                const originalSubs = parseSRT(originalContent);
                let translatedSubs = [];
                log("üü¶ Original subtitles loaded: " + originalSubs.length);
                if (translatedContent) {
                    translatedSubs = parseSRT(translatedContent);
                    log("üü© Translated subtitles loaded: " + translatedSubs.length);
                    showStatus(`üìö Translated subtitles ${translatedSubs.length}‡∂ö‡∑ä load ‡∑Ä‡∑î‡∂´‡∑è`, 'success');
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                const syncedSubs = [];
                const usedIndices = new Set();
                showStatus('üîÑ Smart matching ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è...', 'warning');
                log("üîÑ Smart matching process started...");

                for (let i = 0; i < originalSubs.length; i++) {
                    const originalSub = originalSubs[i];
                    let finalText = null;

                    log(`‚û°Ô∏è Processing subtitle ${i + 1}/${originalSubs.length}`);
                    log("Original: " + originalSub.text.replace(/\n/g, " "));

                    // Try to find match in translated file first
                    if (translatedSubs.length > 0) {
                        log("üß† Searching for best match in translated file...");
                        finalText = await findBestMatch(originalSub.text, translatedSubs, usedIndices, i, originalSubs);
                        if (finalText) {
                            log("‚úÖ Perfect! Found matching translation in file");
                        } else {
                            log("‚ö†Ô∏è No good match found in translated file");
                        }
                    }

                    // If no match found or no translated file, use Google Translate
                    if (!finalText) { 
                        log("üåê Using Google Translate for this subtitle..."); 
                        finalText = await getCachedTranslation(originalSub.text);
                        log("üîÑ Translated successfully via Google");
                    }

                    syncedSubs.push({ index: i + 1, timing: originalSub.timing, text: finalText });
                    log("‚úîÔ∏è Final text: " + finalText.replace(/\n/g, " ").slice(0, 70) + "...");
                    log("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ");
                    await new Promise(resolve => setTimeout(resolve, 100));
                }

                outputContent = syncedSubs.map(sub => `${sub.index}\n${sub.timing}\n${sub.text}\n`).join('\n');

                document.getElementById('previewText').textContent = outputContent.slice(0, 1000) + '\n...';
                document.getElementById('previewBox').style.display = 'block';
                document.getElementById('downloadBtn').style.display = 'inline-block';
                showStatus(`‚úÖ ‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∂∫‡∑í! Subtitles ${syncedSubs.length}‡∂ö‡∑ä smart sync ‡∑Ä‡∑î‡∂´‡∑è!`, 'success');
                log("üèÅ Smart sync completed successfully!");
            } catch (error) {
                showStatus('‚ùå Error: ' + error.message, 'error');
                log("‚ùå Error occurred: " + error.message);
            } finally {
                syncBtn.disabled = false;
                syncBtn.textContent = 'üîÑ Smart Sync ‡∂ö‡∂ª‡∂±‡∑ä‡∂±';
            }
        }

        function downloadOutput() {
            if (!outputContent) return;
            const blob = new Blob([outputContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synced_subtitles.srt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showStatus(message, type) {
            const statusBox = document.getElementById('statusBox');
            statusBox.textContent = message;
            statusBox.className = 'status ' + type;
            statusBox.style.display = 'block';
        }
    </script>
</body>
</html>