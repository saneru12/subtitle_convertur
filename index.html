<!DOCTYPE html>
<html lang="si">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subtitle Timing Synchronizer with Smart Matching</title>
    <link rel="icon" type="image/png" href="https://cdn-icons-png.flaticon.com/512/727/727245.png">
    <!-- ‚úÖ Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CLJE123NKC"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-CLJE123NKC');
    </script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 10px; }
        .container { max-width: 900px; margin: 0 auto; background: white; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); padding: 20px; }
        h1 { text-align: center; color: #333; margin-bottom: 10px; font-size: clamp(20px, 5vw, 32px); }
        .subtitle { text-align: center; color: #666; margin-bottom: 20px; font-size: clamp(12px, 3vw, 16px); padding: 0 10px; }
        .upload-section { display: grid; grid-template-columns: 1fr; gap: 15px; margin-bottom: 20px; }
        @media (min-width: 640px) { .container { padding: 40px; } .upload-section { grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px; } }
        .upload-box { border: 3px dashed #667eea; border-radius: 15px; padding: 20px; text-align: center; transition: all 0.3s; cursor: pointer; }
        .upload-box:hover { border-color: #764ba2; background: #f8f9ff; }
        .upload-box.uploaded { border-color: #10b981; background: #f0fdf4; }
        .upload-box h3 { color: #333; margin-bottom: 10px; font-size: clamp(16px, 4vw, 20px); }
        .upload-box p { color: #666; font-size: clamp(12px, 3vw, 14px); margin-bottom: 15px; }
        .btn { padding: 10px 20px; border: none; border-radius: 10px; font-size: clamp(14px, 3vw, 16px); font-weight: bold; cursor: pointer; transition: all 0.3s; }
        @media (min-width: 640px) { .btn { padding: 12px 30px; } }
        .btn-upload { background: #667eea; color: white; }
        .btn-upload:hover { background: #5568d3; }
        .btn-sync { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-size: clamp(14px, 4vw, 18px); padding: 12px 25px; width: 100%; }
        @media (min-width: 640px) { .btn-sync { padding: 15px 40px; width: auto; } }
        .btn-sync:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
        .btn-sync:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-download { background: #10b981; color: white; font-size: clamp(14px, 4vw, 18px); padding: 12px 25px; width: 100%; }
        @media (min-width: 640px) { .btn-download { padding: 15px 40px; width: auto; } }
        .btn-download:hover { background: #059669; }
        .button-group { display: flex; flex-direction: column; gap: 10px; justify-content: center; margin-bottom: 20px; }
        @media (min-width: 640px) { .button-group { flex-direction: row; gap: 15px; } }
        .status { background: #eff6ff; border: 2px solid #3b82f6; border-radius: 10px; padding: 12px; text-align: center; margin-bottom: 15px; font-weight: bold; color: #1e40af; font-size: clamp(12px, 3vw, 16px); }
        .status.success { background: #f0fdf4; border-color: #10b981; color: #065f46; }
        .status.error { background: #fef2f2; border-color: #ef4444; color: #991b1b; }
        .status.warning { background: #fffbeb; border-color: #f59e0b; color: #92400e; }
        .preview { background: #f9fafb; border: 2px solid #e5e7eb; border-radius: 10px; padding: 15px; margin-bottom: 15px; display: none; }
        .preview h3 { color: #333; margin-bottom: 10px; font-size: clamp(16px, 4vw, 20px); }
        .preview pre { background: white; padding: 12px; border-radius: 8px; border: 1px solid #e5e7eb; max-height: 250px; overflow-y: auto; font-size: clamp(10px, 2.5vw, 12px); white-space: pre-wrap; word-break: break-word; }
        .instructions { background: #fef3c7; border: 2px solid #fbbf24; border-radius: 10px; padding: 15px; }
        .instructions h4 { color: #92400e; margin-bottom: 10px; font-size: clamp(14px, 3.5vw, 18px); }
        .instructions ol { color: #78350f; padding-left: 20px; font-size: clamp(12px, 3vw, 14px); }
        .instructions li { margin-bottom: 5px; }
        .instructions p { font-size: clamp(11px, 2.5vw, 13px); }
        input[type="file"] { display: none; }
        .icon { font-size: clamp(32px, 8vw, 48px); margin-bottom: 10px; }
        .checkmark { color: #10b981; font-size: clamp(16px, 4vw, 20px); margin-top: 10px; display: none; }
        #downloadBtn { display: none; }
        .optional-badge { display: inline-block; background: #fbbf24; color: white; padding: 3px 8px; border-radius: 12px; font-size: clamp(9px, 2vw, 11px); font-weight: bold; margin-left: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé¨ Subtitle Smart Synchronizer</h1>
        <p class="subtitle">Original timing + Sinhala translation smart matching</p>

        <div class="upload-section">
            <div class="upload-box" id="originalBox" onclick="document.getElementById('originalFile').click()">
                <div class="icon">‚è±Ô∏è</div>
                <h3>Original Subtitle</h3>
                <p>(‡∂ï‡∂±‡∑ë‡∂∏ ‡∂∑‡∑è‡∑Ç‡∑è‡∑Ä‡∂ö - timing ‡∑É‡∂≥‡∑Ñ‡∑è)</p>
                <button class="btn btn-upload">üìÅ Upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
                <div class="checkmark" id="originalCheck">‚úì Uploaded</div>
                <input type="file" id="originalFile" accept=".srt">
            </div>

            <div class="upload-box" id="translatedBox" onclick="document.getElementById('translatedFile').click()">
                <div class="icon">üìù</div>
                <h3>Sinhala Subtitle <span class="optional-badge">‡∑Ä‡∑í‡∂ö‡∂Ω‡∑ä‡∂¥</span></h3>
                <p>(‡∂¥‡∂ª‡∑í‡∑Ä‡∂ª‡∑ä‡∂≠‡∂±‡∂∫ ‡∂ö‡∑Ö - ‡∑Ä‡∂†‡∂± ‡∑É‡∂≥‡∑Ñ‡∑è)</p>
                <button class="btn btn-upload">üìÅ Upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
                <div class="checkmark" id="translatedCheck">‚úì Uploaded</div>
                <input type="file" id="translatedFile" accept=".srt">
            </div>
        </div>

        <div id="statusBox" class="status" style="display:none;"></div>

        <div class="button-group">
            <button class="btn btn-sync" id="syncBtn" onclick="syncSubtitles()">üîÑ Smart Sync ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
            <button class="btn btn-download" id="downloadBtn" onclick="downloadOutput()">‚¨áÔ∏è Download ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</button>
        </div>

        <!-- üÜï Real-time Log Box -->
        <div class="preview" id="logBox" style="display:none; background:#000; color:#0f0; max-height:200px; overflow-y:auto;">
            <h3 style="color:white;">Live Log:</h3>
            <pre id="logText" style="background:#000; color:#0f0; border:none; padding:5px; margin:0; white-space:pre-wrap;"></pre>
        </div>

        <div class="preview" id="previewBox">
            <h3>Preview:</h3>
            <pre id="previewText"></pre>
        </div>

        <div class="instructions">
            <h4>üìå ‡∂∑‡∑è‡∑Ä‡∑í‡∂≠‡∑è ‡∂ö‡∂ª‡∂± ‡∂Ü‡∂ö‡∑è‡∂ª‡∂∫:</h4>
            <ol>
                <li>Original subtitle file ‡∂ë‡∂ö upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂± (timing ‡∑Ä‡∂Ω‡∂ß)</li>
                <li><strong>‡∑Ä‡∑í‡∂ö‡∂Ω‡∑ä‡∂¥:</strong> Sinhala translated subtitle file ‡∂ë‡∂ö upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</li>
                <li>"Smart Sync" button ‡∂ë‡∂ö click ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</li>
                <li>System ‡∂ë‡∂ö Original ‡∂ë‡∂ö‡∑ö English ‡∑É‡∑Ñ Translated ‡∂ë‡∂ö‡∑ö Sinhala compare ‡∂ö‡∂ª‡∂Ω‡∑è best match ‡∑Ñ‡∑ú‡∂∫‡∑è‡∂ú‡∑ô‡∂± sync ‡∂ö‡∂ª‡∂∫‡∑í</li>
                <li>Output file ‡∂ë‡∂ö download ‡∂ö‡∂ª‡∂±‡∑ä‡∂±</li>
            </ol>
            <p style="margin-top:10px;"><strong>üß† Smart Matching:</strong> Original ‡∂ë‡∂ö‡∑ö "Sara" ‡∂ö‡∑í‡∂∫‡∂Ω ‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è ‡∂±‡∂∏‡∑ä, Translated ‡∂ë‡∂ö‡∑ö "‡∑É‡∑è‡∂ª‡∑è" ‡∑Ñ‡∑ú‡∂∫‡∑è‡∂ú‡∑ô‡∂± ‡∂í‡∂ö ‡∂Ø‡∑è‡∂±‡∑Ä‡∑è. Match ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ñ‡∑ú‡∂∫‡∑è‡∂ú‡∂±‡∑ä‡∂± ‡∂∂‡∑ê‡∂ª‡∑í ‡∂±‡∂∏‡∑ä Google Translate use ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è!</p>
        </div>
    </div>

    <script>
        let originalContent = null;
        let translatedContent = null;
        let outputContent = null;

        // üÜï Real-time log function
        function log(message) {
            const logBox = document.getElementById("logBox");
            const logText = document.getElementById("logText");
            logBox.style.display = "block";
            logText.textContent += message + "\n";
            logBox.scrollTop = logBox.scrollHeight; // auto scroll
        }

        document.getElementById('originalFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                originalContent = event.target.result;
                document.getElementById('originalBox').classList.add('uploaded');
                document.getElementById('originalCheck').style.display = 'block';
                showStatus('Original subtitle ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä upload ‡∑Ä‡∑î‡∂´‡∑è ‚úì', 'success');
                log("üü¶ Original subtitle loaded");
            };
            reader.readAsText(file);
        });

        document.getElementById('translatedFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                translatedContent = event.target.result;
                document.getElementById('translatedBox').classList.add('uploaded');
                document.getElementById('translatedCheck').style.display = 'block';
                showStatus('Sinhala subtitle ‡∂ú‡∑ú‡∂±‡∑î‡∑Ä upload ‡∑Ä‡∑î‡∂´‡∑è ‚úì', 'success');
                log("üü© Translated subtitle loaded");
            };
            reader.readAsText(file);
        });

        function parseSRT(content) {
            const blocks = content.trim().split(/\n\s*\n/);
            return blocks.map(block => {
                const lines = block.split('\n');
                const index = lines[0];
                const timing = lines[1];
                const text = lines.slice(2).join('\n');
                return { index, timing, text };
            });
        }

        function normalizeText(text) {
            return text.toLowerCase().replace(/[.,!?;:"""''\-‚Äî()[\]{}]/g, '').replace(/\s+/g, ' ').trim();
        }

        function calculateSimilarity(str1, str2) {
            const len1 = str1.length;
            const len2 = str2.length;
            if (len1 === 0) return len2;
            if (len2 === 0) return len1;
            let matches = 0;
            const maxLen = Math.max(len1, len2);
            for (let i = 0; i < Math.min(len1, len2); i++) {
                if (str1[i] === str2[i]) matches++;
            }
            return matches / maxLen;
        }

        async function translateText(text) {
            try {
                const response = await fetch(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=auto&tl=si&dt=t&q=${encodeURIComponent(text)}`);
                const data = await response.json();
                if (data && data[0] && data[0][0] && data[0][0][0]) {
                    let translatedText = data[0][0][0];
                    translatedText = makeSinhalaConversational(translatedText);
                    return translatedText;
                }
                return text;
            } catch (error) {
                console.error('Translation error:', error);
                return text;
            }
        }

        function makeSinhalaConversational(text) {
            let result = text;
            const conversions = {
                '‡∂á‡∂≠': '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑Ä‡∑è','‡∂±‡∑ê‡∂≠': '‡∂±‡∑ë','‡∂î‡∂∂': '‡∂î‡∂∫‡∑è','‡∂î‡∑Ñ‡∑î': '‡∂ë‡∂∫‡∑è','‡∂á‡∂∫': '‡∂ë‡∂∫‡∑è','‡∂ë‡∂∫': '‡∂í‡∂ö','‡∂∏‡∑ô‡∂∫': '‡∂∏‡∑ö‡∂ö',
                '‡∂ö‡∂ª‡∂±‡∑î ‡∂Ω‡∑ê‡∂∂‡∑ö': '‡∂ö‡∂ª‡∂±‡∑Ä‡∑è','‡∂Ω‡∑ê‡∂∂‡∑ö': '‡∂Ω‡∑ê‡∂∂‡∑ô‡∂±‡∑Ä‡∑è','‡∑Ä‡∑ö': '‡∑Ä‡∑ô‡∂±‡∑Ä‡∑è','‡∑Ä‡∑í‡∂∫': '‡∂ã‡∂±‡∑è','‡∂ö‡∑Ö': '‡∂ö‡∑Ö‡∑è','‡∂∫‡∂±‡∑Ä‡∑è': '‡∂∫‡∂±‡∑Ä‡∑è',
                '‡∂ë‡∂±‡∑Ä‡∑è': '‡∂ë‡∂±‡∑Ä‡∑è','‡∂á‡∂≠‡∑ä‡∂≠‡∑ö': '‡∂≠‡∑í‡∂∫‡∑ô‡∂±‡∑ä‡∂±‡∑ö','‡∂ö‡∂ª‡∂∏‡∑í': '‡∂ö‡∂ª‡∂±‡∑Ä‡∑è','‡∂∫‡∂∏‡∑í': '‡∂∫‡∂±‡∑Ä‡∑è','‡∂ë‡∂∏‡∑í': '‡∂ë‡∂±‡∑Ä‡∑è','‡∂ö‡∑Ö‡∑ô‡∂∏‡∑í': '‡∂ö‡∑Ö‡∑è',
                '‡∂ú‡∑í‡∂∫‡∑ô‡∂∏‡∑í': '‡∂ú‡∑í‡∂∫‡∑è','‡∂Ü‡∑Ä‡∑ô‡∂∏‡∑í': '‡∂Ü‡∑Ä‡∑è','‡∂î‡∂∂‡∂ß': '‡∂î‡∂∫‡∑è‡∂ß'
            };
            for (const [formal, informal] of Object.entries(conversions)) {
                const regex = new RegExp('\\b' + formal + '\\b', 'g');
                result = result.replace(regex, informal);
            }
            result = result.replace(/‡∂∫$/g, '');
            return result;
        }

        async function findBestMatch(originalText, translatedSubs, usedIndices) {
            let bestMatch = null, bestScore = 0, bestIndex = -1;
            const normalizedOriginal = normalizeText(originalText);
            for (let i = 0; i < translatedSubs.length; i++) {
                if (usedIndices.has(i)) continue;
                const translatedText = translatedSubs[i].text;
                const tempTranslation = await translateText(originalText);
                const normalizedTranslation = normalizeText(tempTranslation);
                const normalizedTranslated = normalizeText(translatedText);
                const similarity = calculateSimilarity(normalizedTranslation, normalizedTranslated);
                if (similarity > bestScore) { bestScore = similarity; bestMatch = translatedText; bestIndex = i; }
                if (similarity > 0.7) break;
            }
            if (bestScore > 0.4 && bestIndex !== -1) { usedIndices.add(bestIndex); return bestMatch; }
            return null;
        }

        async function syncSubtitles() {
            if (!originalContent) { showStatus('‚ö†Ô∏è Original subtitle file ‡∂ë‡∂ö upload ‡∂ö‡∂ª‡∂±‡∑ä‡∂±!', 'error'); return; }
            const syncBtn = document.getElementById('syncBtn');
            syncBtn.disabled = true;
            syncBtn.textContent = '‚è≥ Processing...';
            document.getElementById("logText").textContent = "";

            try {
                const originalSubs = parseSRT(originalContent);
                let translatedSubs = [];
                log("üü¶ Original subtitles loaded: " + originalSubs.length);
                if (translatedContent) {
                    translatedSubs = parseSRT(translatedContent);
                    log("üü© Translated subtitles loaded: " + translatedSubs.length);
                    showStatus(`üìö Translated subtitles ${translatedSubs.length}‡∂ö‡∑ä load ‡∑Ä‡∑î‡∂´‡∑è`, 'success');
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                const syncedSubs = [];
                const usedIndices = new Set();
                showStatus('üîÑ Smart matching ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è...', 'warning');
                log("üîÑ Smart matching process started...");

                for (let i = 0; i < originalSubs.length; i++) {
                    const originalSub = originalSubs[i];
                    let finalText = null;

                    log(`‚û°Ô∏è Processing subtitle ${i + 1}/${originalSubs.length}`);
                    log("Original: " + originalSub.text.replace(/\n/g, " "));

                    if (translatedSubs.length > 0) {
                        log("üß† Finding best match...");
                        finalText = await findBestMatch(originalSub.text, translatedSubs, usedIndices);
                        if (finalText) log("‚úÖ Matched from translated file");
                    }

                    if (!finalText) { log("üåê No match found ‚Äî translating via Google..."); finalText = await translateText(originalSub.text); }

                    syncedSubs.push({ index: i + 1, timing: originalSub.timing, text: finalText });
                    log("‚úîÔ∏è Done -> " + finalText.replace(/\n/g, " ").slice(0, 60) + "...");
                    log("---------------------------------------");
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                outputContent = syncedSubs.map(sub => `${sub.index}\n${sub.timing}\n${sub.text}\n`).join('\n');

                document.getElementById('previewText').textContent = outputContent.slice(0, 1000) + '\n...';
                document.getElementById('previewBox').style.display = 'block';
                document.getElementById('downloadBtn').style.display = 'inline-block';
                showStatus(`‚úÖ ‡∑É‡∑è‡∂ª‡∑ä‡∂Æ‡∂ö‡∂∫‡∑í! Subtitles ${syncedSubs.length}‡∂ö‡∑ä smart sync ‡∑Ä‡∑î‡∂´‡∑è!`, 'success');
                log("üèÅ Smart sync completed successfully!");
            } catch (error) {
                showStatus('‚ùå Error: ' + error.message, 'error');
                log("‚ùå Error occurred: " + error.message);
            } finally {
                syncBtn.disabled = false;
                syncBtn.textContent = 'üîÑ Smart Sync ‡∂ö‡∂ª‡∂±‡∑ä‡∂±';
            }
        }

        function downloadOutput() {
            if (!outputContent) return;
            const blob = new Blob([outputContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'synced_subtitles.srt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function showStatus(message, type) {
            const statusBox = document.getElementById('statusBox');
            statusBox.textContent = message;
            statusBox.className = 'status ' + type;
            statusBox.style.display = 'block';
        }
    </script>
</body>
</html>
